diff --git a/BUILD.bazel b/BUILD.bazel
new file mode 100644
index 0000000..b2cd279
--- /dev/null
+++ b/BUILD.bazel
@@ -0,0 +1,10 @@
+load("@boost.rules.tools//:tools.bzl", "boost_library")
+
+boost_library(
+    name = "stl_interfaces",
+    deps = [
+        "@boost.assert//:assert",
+        "@boost.config//:config",
+        "@boost.type_traits//:type_traits",
+    ],
+)
diff --git a/MODULE.bazel b/MODULE.bazel
new file mode 100755
index 0000000..7e35a82
--- /dev/null
+++ b/MODULE.bazel
@@ -0,0 +1,11 @@
+module(
+    name = "boost.stl_interfaces",
+    version = "1.83.0.bcr.1",
+    compatibility_level = 1,
+)
+
+bazel_dep(name = "boost.rules.tools", version = "1.0.0")
+bazel_dep(name = "platforms", version = "0.0.8")
+bazel_dep(name = "boost.assert", version = "1.83.0.bcr.1")
+bazel_dep(name = "boost.config", version = "1.83.0.bcr.1")
+bazel_dep(name = "boost.type_traits", version = "1.83.0.bcr.1")
diff --git a/WORKSPACE.bazel b/WORKSPACE.bazel
new file mode 100644
index 0000000..be0754f
--- /dev/null
+++ b/WORKSPACE.bazel
@@ -0,0 +1 @@
+# SEE: MODULE.bazel
diff --git a/bazel_test/BUILD.bazel b/bazel_test/BUILD.bazel
new file mode 100644
index 0000000..b107301
--- /dev/null
+++ b/bazel_test/BUILD.bazel
@@ -0,0 +1,16 @@
+load("@boost.rules.tools//:tools.bzl", "boost_test_set")
+
+DEPS = [
+    "@boost.stl_interfaces//:stl_interfaces",
+]
+
+test_suite(
+    name = "tests",
+    tests = boost_test_set(
+        file_extensions = ".cc",
+        names = [
+            "stl_interfaces_test",
+        ],
+        deps = DEPS,
+    ),
+)
diff --git a/bazel_test/stl_interfaces_test.cc b/bazel_test/stl_interfaces_test.cc
new file mode 100644
index 0000000..9fd8b7f
--- /dev/null
+++ b/bazel_test/stl_interfaces_test.cc
@@ -0,0 +1,51 @@
+#include <boost/stl_interfaces/iterator_interface.hpp>
+
+#include <algorithm>
+#include <array>
+#include <vector>
+
+template <typename Pred>
+struct filtered_int_iterator
+    : boost::stl_interfaces::iterator_interface<
+          filtered_int_iterator<Pred>, std::bidirectional_iterator_tag, int> {
+  filtered_int_iterator() : it_(nullptr) {}
+  filtered_int_iterator(int *it, int *last, Pred pred)
+      : it_(it), last_(last), pred_(std::move(pred)) {
+    it_ = std::find_if(it_, last_, pred_);
+  }
+
+  filtered_int_iterator &operator++() {
+    it_ = std::find_if(std::next(it_), last_, pred_);
+    return *this;
+  }
+
+  int *base() const { return it_; }
+
+private:
+  friend boost::stl_interfaces::access;
+  int *&base_reference() noexcept { return it_; }
+  int *base_reference() const noexcept { return it_; }
+
+  int *it_;
+  int *last_;
+  Pred pred_;
+};
+
+template <typename Pred>
+filtered_int_iterator<Pred> make_filtered_int_iterator(int *it, int *last, Pred pred) {
+  return filtered_int_iterator<Pred>(it, last, std::move(pred));
+}
+
+int main() {
+  std::array<int, 8> ints = {{0, 1, 2, 3, 4, 5, 6, 7}};
+  int *const ints_first = ints.data();
+  int *const ints_last = ints.data() + ints.size();
+
+  auto even = [](int x) { return (x % 2) == 0; };
+  auto first = make_filtered_int_iterator(ints_first, ints_last, even);
+  auto last = make_filtered_int_iterator(ints_last, ints_last, even);
+
+  std::vector<int> ints_copy;
+  std::copy(first, last, std::back_inserter(ints_copy));
+  return ints_copy == (std::vector<int>{0, 2, 4, 6}) ? 0 : 1;
+}
